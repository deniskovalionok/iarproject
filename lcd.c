/*
lcd.c
controls 
*/

#include "lcd.h"
#include "main.h"
#include "graphic.h"



/* transfer state */
__IO uint32_t wTransferState = TRANSFER_WAIT;



/* Buffer used for transmission */
__no_init uint8_t cmdbuf[BUFFERSIZE];
__no_init uint8_t lcdbuf[LCD_WIDTH*LCD_BHEIGHT/LCD_PIXPERBYTE] @0x20000000;

uint8_t lcd_height = LCD_BHEIGHT;
uint32_t LCDBUFSIZE;

/*
turn off LCD
*/
void turnOffLCD()
{
	HAL_GPIO_WritePin(RESET_GPIO_PORT, RESET_PIN, GPIO_PIN_SET);
	lcd_off();
	checkTransferState();
	HAL_GPIO_WritePin(RESET_GPIO_PORT, RESET_PIN, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(EN_GPIO_PORT, EN_PIN, GPIO_PIN_SET);
	HAL_GPIO_WritePin(CNTRL_GPIO_PORT, CNTRL_PIN, GPIO_PIN_RESET);
}

/*
turn on LCD
*/
void turnOnLCD()
{
	HAL_GPIO_WritePin(CNTRL_GPIO_PORT, CNTRL_PIN, GPIO_PIN_SET);
	HAL_GPIO_WritePin(EN_GPIO_PORT, EN_PIN, GPIO_PIN_RESET);
	HAL_Delay(100);//!!!!!! вынужденная пауза
	HAL_GPIO_WritePin(RESET_GPIO_PORT, RESET_PIN, GPIO_PIN_RESET);
	HAL_Delay(1);
	HAL_GPIO_WritePin(RESET_GPIO_PORT, RESET_PIN, GPIO_PIN_SET);
	lcd_off();
	lcd_init();
	checkTransferState();
	lcd_clear();
	checkTransferState();
	HAL_Delay(100);
	lcd_on();
	checkTransferState();

}

/*
initialization of lcd
*/
void lcd_init()
{
	lcd_changeHeight();
	int i=0;
	HAL_GPIO_WritePin(RS_GPIO_PORT, RS_PIN, GPIO_PIN_RESET);	//set command mode
	cmdbuf[i++] = 0xAE;//turn off display
	cmdbuf[i++] = 0xD5;//Set Display Clock Divide Ratio/Oscillator Frequenc
	cmdbuf[i++] = 0x80;//Set Display Clock Divide Ratio/Oscillator Frequenc
	cmdbuf[i++] = 0xA8;//Set Multiplex Ratio
	cmdbuf[i++] = lcd_height-1;//Set Multiplex Ratio
	cmdbuf[i++] = 0xD3;//Set Display Offset 
	cmdbuf[i++] = 0x00;//Set Display Offset 
	cmdbuf[i++] = 0x20;//Set address mode
	cmdbuf[i++] = 0x00;//Set address mode 

	cmdbuf[i++] = 0x21;//set column
	cmdbuf[i++] = 0x00;//number
	cmdbuf[i++] = LCD_WIDTH-1;//number
	cmdbuf[i++] = 0x22;//Set page
	cmdbuf[i++] = 0x00;//number
	cmdbuf[i++] = lcd_height/LCD_PIXPERBYTE-1;//number

	cmdbuf[i++] = 0xD6;//Disable Zoom in Mode
	cmdbuf[i++] = 0x00;//Disable Zoom in Mode
	
	cmdbuf[i++] = 0x40;//Set Display Start Line 
	cmdbuf[i++] = 0x8D;//Set Charge Pump 
	cmdbuf[i++] = 0x14;//Set Charge Pump 0x10=VCC Supplied Externally  OR 0x14=VCC Generated by Internal DC/DC Circuit
	cmdbuf[i++] = 0xA1;//Set Segment Re-Map 
	cmdbuf[i++] = 0xC8;//Set COM Output Scan Direction 
	cmdbuf[i++] = 0xDA;//Set COM Pins Hardware Configuration 
	if(lcd_height==32)
		cmdbuf[i++] = 0x02;//Set COM Pins Hardware Configuration 
	else
		cmdbuf[i++] = 0x12;//Set COM Pins Hardware Configuration 
	cmdbuf[i++] = 0x81;//Set Contrast Control
	cmdbuf[i++] = 0xff;//Set Contrast Control
	cmdbuf[i++] = 0xD9;//Set Pre-Charge Period 
	cmdbuf[i++] = 0xF1;//Set Pre-Charge Period 0x22=VCC Supplied Externally  OR 0xF1=VCC Generated by Internal DC/DC Circuit
	cmdbuf[i++] = 0xDB;//Set VCOMH Deselect Level 0xDB, 0x40
	cmdbuf[i++] = 0x30;//Set VCOMH Deselect Level 0xDB, 0x40
	cmdbuf[i++] = 0xA4;//Set Entire Display On/Off 
	cmdbuf[i++] = 0xA6;//Set Normal/Inverse Display 
	wTransferState = TRANSFER_WAIT;
	if(HAL_SPI_Transmit_DMA(&SpiHandle, (uint8_t*)cmdbuf, i) != HAL_OK)
	{
		/* Transfer error in transmission process */
		Error_Handler();
	}

  /*##-3- Wait for the end of the transfer ###################################*/
  /*  Before starting a new communication transfer, you must wait the callback call
      to get the transfer complete confirmation or an error detection.
      For simplicity reasons, this example is just waiting till the end of the
      transfer, but application may perform other tasks while transfer operation
      is ongoing. */
	while (wTransferState == TRANSFER_WAIT)
	{
		HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE);
	}	
	
}



//clear screen
void lcd_clear()
{
	lcd_fill(0);
}

void lcd_fill(unsigned char fillbyte)
{
	int i=0;
	HAL_GPIO_WritePin(RS_GPIO_PORT, RS_PIN, GPIO_PIN_RESET);	//set command mode
	cmdbuf[i++] = 0x21;//set column
	cmdbuf[i++] = 0x00;//number
	cmdbuf[i++] = LCD_WIDTH-1;//number
	cmdbuf[i++] = 0x22;//Set page
	cmdbuf[i++] = 0x00;//number
	cmdbuf[i++] = lcd_height/LCD_PIXPERBYTE-1;//number
	wTransferState = TRANSFER_WAIT;
	if(HAL_SPI_Transmit_DMA(&SpiHandle, (uint8_t*)cmdbuf, i) != HAL_OK)
	{
		/* Transfer error in transmission process */
		Error_Handler();
	}	;
  /*##-3- Wait for the end of the transfer ###################################*/
  /*  Before starting a new communication transfer, you must wait the callback call
      to get the transfer complete confirmation or an error detection.
      For simplicity reasons, this example is just waiting till the end of the
      transfer, but application may perform other tasks while transfer operation
      is ongoing. */
	while (wTransferState == TRANSFER_WAIT)
	{
		HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE);
	}	

	
	HAL_GPIO_WritePin(RS_GPIO_PORT, RS_PIN, GPIO_PIN_SET);	//set data mode
	for(int i=0;i<LCDBUFSIZE;i++)
		lcdbuf[i] = fillbyte;//pixel color
	wTransferState = TRANSFER_WAIT;
	if(HAL_SPI_Transmit_DMA(&SpiHandle, (uint8_t*)lcdbuf, LCDBUFSIZE) != HAL_OK)
	{
		/* Transfer error in transmission process */
		Error_Handler();
	}	;
  /*##-3- Wait for the end of the transfer ###################################*/
  /*  Before starting a new communication transfer, you must wait the callback call
      to get the transfer complete confirmation or an error detection.
      For simplicity reasons, this example is just waiting till the end of the
      transfer, but application may perform other tasks while transfer operation
      is ongoing. */
	while (wTransferState == TRANSFER_WAIT)
	{
		HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE);
	}	
}


/*
show buffer
*/
void lcd_show()
{
	int i=0;
	HAL_GPIO_WritePin(RS_GPIO_PORT, RS_PIN, GPIO_PIN_RESET);	//set command mode
	cmdbuf[i++] = 0x21;//set column
	cmdbuf[i++] = 0x00;//number
	cmdbuf[i++] = LCD_WIDTH-1;//number
	cmdbuf[i++] = 0x22;//Set page
	cmdbuf[i++] = 0x00;//number
	cmdbuf[i++] = lcd_height/LCD_PIXPERBYTE-1;//number
	wTransferState = TRANSFER_WAIT;
	if(HAL_SPI_Transmit_DMA(&SpiHandle, (uint8_t*)cmdbuf, i) != HAL_OK)
	{
		/* Transfer error in transmission process */
		Error_Handler();
	}	;
  /*##-3- Wait for the end of the transfer ###################################*/
  /*  Before starting a new communication transfer, you must wait the callback call
      to get the transfer complete confirmation or an error detection.
      For simplicity reasons, this example is just waiting till the end of the
      transfer, but application may perform other tasks while transfer operation
      is ongoing. */
	while (wTransferState == TRANSFER_WAIT)
	{
		HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE);
	}	

	
	HAL_GPIO_WritePin(RS_GPIO_PORT, RS_PIN, GPIO_PIN_SET);	//set data mode
	wTransferState = TRANSFER_WAIT;
	if(HAL_SPI_Transmit_DMA(&SpiHandle, (uint8_t*)lcdbuf, LCDBUFSIZE) != HAL_OK)
	{
		/* Transfer error in transmission process */
		Error_Handler();
	}	;
  /*##-3- Wait for the end of the transfer ###################################*/
  /*  Before starting a new communication transfer, you must wait the callback call
      to get the transfer complete confirmation or an error detection.
      For simplicity reasons, this example is just waiting till the end of the
      transfer, but application may perform other tasks while transfer operation
      is ongoing. */
	while (wTransferState == TRANSFER_WAIT)
	{
		HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE);
	}	
}

void lcdbuf_clear()
{
	for(int i=0;i<LCDBUFSIZE;i++)
		lcdbuf[i]=0;
}

//draw point
void lcdbuf_plot(unsigned int x, unsigned int y)
{
	int adr = (y>>3)*LCD_WIDTH+x;
	if(adr>=LCDBUFSIZE)return;	//failed
	unsigned char byte = 1;
	y = y&0x07;
	if(y)
		byte = 1<<y;
	lcdbuf[adr] |= byte;//pixel color

}




//turn off lcd command
void lcd_off(void)
{
	HAL_GPIO_WritePin(RS_GPIO_PORT, RS_PIN, GPIO_PIN_RESET);	//set command mode
	cmdbuf[0] = 0xAE;//turn off display
	wTransferState = TRANSFER_WAIT;
	if(HAL_SPI_Transmit_DMA(&SpiHandle, (uint8_t*)cmdbuf,  1) != HAL_OK)
	{
		/* Transfer error in transmission process */
		Error_Handler();
	}

  /*##-3- Wait for the end of the transfer ###################################*/
  /*  Before starting a new communication transfer, you must wait the callback call
      to get the transfer complete confirmation or an error detection.
      For simplicity reasons, this example is just waiting till the end of the
      transfer, but application may perform other tasks while transfer operation
      is ongoing. */
	while (wTransferState == TRANSFER_WAIT)
	{
		HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE);
	}
}




//turn on lcd command
void lcd_on(void)
{
	HAL_GPIO_WritePin(RS_GPIO_PORT, RS_PIN, GPIO_PIN_RESET);	//set command mode
	cmdbuf[0] = 0xAF;//turn on display
	wTransferState = TRANSFER_WAIT;
	if(HAL_SPI_Transmit_DMA(&SpiHandle, (uint8_t*)cmdbuf, 1) != HAL_OK)
	{
		/* Transfer error in transmission process */
		Error_Handler();
	}

  /*##-3- Wait for the end of the transfer ###################################*/
  /*  Before starting a new communication transfer, you must wait the callback call
      to get the transfer complete confirmation or an error detection.
      For simplicity reasons, this example is just waiting till the end of the
      transfer, but application may perform other tasks while transfer operation
      is ongoing. */
	while (wTransferState == TRANSFER_WAIT)
	{
		HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE);
	}
}

/*
recalculate some variables that depends on lcd height
*/
void lcd_changeHeight()
{
	LCDBUFSIZE  = (LCD_WIDTH*lcd_height/LCD_PIXPERBYTE);
	Y_SCREEN_SIZE = lcd_height;
	Y_SCREEN_MAX = Y_SCREEN_SIZE-1;
	screenHigh2 = (DWORD)(screenHigh+LCDBUFSIZE);
}
